/** @license React vundefined
 * eslint-plugin-react-hooks.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';function Q(a){return"Identifier"===a.type?/^use[A-Z0-9].*$/.test(a.name):"MemberExpression"===a.type&&!a.computed&&Q(a.property)?(a=a.object,"Identifier"===a.type&&"React"===a.name):!1}function U(a){return"Identifier"===a.type?!/^[a-z]/.test(a.name):!1}function aa(a){for(;a;){var b=W(a);if(b&&(U(b)||Q(b)))return!0;a=a.parent}return!1}
function W(a){if("FunctionDeclaration"===a.type||"FunctionExpression"===a.type&&a.id)return a.id;if("FunctionExpression"===a.type||"ArrowFunctionExpression"===a.type)return"VariableDeclarator"===a.parent.type&&a.parent.init===a?a.parent.id:"AssignmentExpression"===a.parent.type&&a.parent.right===a&&"="===a.parent.operator?a.parent.left:"Property"!==a.parent.type||a.parent.value!==a||a.parent.computed?"AssignmentPattern"!==a.parent.type||a.parent.right!==a||a.parent.computed?void 0:a.parent.left:a.parent.key}
function ba(a){function b(){return{isRequired:!1,isSatisfiedRecursively:!1,hasRequiredNodesBelow:!1,children:new Map}}function e(a,l){l=l.split(".");var k=!0,h=!1,e=void 0;try{for(var f=l[Symbol.iterator](),p;!(k=(p=f.next()).done);k=!0){var t=p.value,g=a.children.get(t);g||(g=b(),a.children.set(t,g));a=g}}catch(E){h=!0,e=E}finally{try{!k&&f.return&&f.return()}finally{if(h)throw e;}}return a}function f(a,l,b){l=l.split(".");var k=!0,f=!1,h=void 0;try{for(var e=l[Symbol.iterator](),g;!(k=(g=e.next()).done);k=
!0){var t=a.children.get(g.value);if(!t)break;b(t);a=t}}catch(E){f=!0,h=E}finally{try{!k&&e.return&&e.return()}finally{if(f)throw h;}}}function l(a,b,e,f){a.children.forEach(function(a,k){var h=f(k);a.isSatisfiedRecursively?a.hasRequiredNodesBelow&&e.add(h):a.isRequired?b.add(h):l(a,b,e,function(a){return h+"."+a})})}var t=a.dependencies,n=a.declaredDependencies,v=a.optionalDependencies,h=a.externalDependencies,r=a.isEffect,B=b();t.forEach(function(a,l){e(B,l).isRequired=!0;f(B,l,function(a){a.hasRequiredNodesBelow=
!0})});n.forEach(function(a){e(B,a.key).isSatisfiedRecursively=!0});v.forEach(function(a){e(B,a).isSatisfiedRecursively=!0});a=new Set;var g=new Set;l(B,a,g,function(a){return a});var y=[],C=new Set,D=new Set;n.forEach(function(a){a=a.key;g.has(a)?-1===y.indexOf(a)?y.push(a):D.add(a):!r||a.endsWith(".current")||h.has(a)?C.add(a):-1===y.indexOf(a)&&y.push(a)});a.forEach(function(a){y.push(a)});return{suggestedDependencies:y,unnecessaryDependencies:C,duplicateDependencies:D,missingDependencies:a}}
function ca(a){var b=a.declaredDependenciesNode,e=a.componentScope,f=a.scope;return a.declaredDependencies.map(function(a){a=e.set.get(a.key);if(null==a)return null;var b=a.defs[0];return null==b?null:"Variable"===b.type&&"VariableDeclarator"===b.node.type&&null!=b.node.init&&("ArrowFunctionExpression"===b.node.init.type||"FunctionExpression"===b.node.init.type)||"FunctionName"===b.type&&"FunctionDeclaration"===b.node.type?a:null}).filter(Boolean).map(function(a){var e=a.defs[0];a:{for(var l=!1,v=
0;v<a.references.length;v++){var h=a.references[v];if(h.writeExpr)if(l){a=!0;break a}else{l=!0;continue}for(var r=h.from;r!==f&&null!=r;)r=r.upper;if(r!==f&&!da(b,h.identifier)){a=!0;break a}}a=!1}return{fn:e,suggestUseCallback:a}})}function ea(a){return"MemberExpression"!==a.parent.type||a.parent.object!==a||"current"===a.parent.property.name||a.parent.computed||null!=a.parent.parent&&"CallExpression"===a.parent.parent.type&&a.parent.parent.callee===a.parent?a:ea(a.parent)}
function Y(a){if("Identifier"===a.type)return a.name;if("MemberExpression"!==a.type||a.computed)throw Error("Unsupported node type: "+a.type);var b=Y(a.object);a=Y(a.property);return b+"."+a}function ha(a){return"MemberExpression"!==a.type||"Identifier"!==a.object.type||"React"!==a.object.name||"Identifier"!==a.property.type||a.computed?a:a.property}
function ia(a,b){var e=ha(a);if("Identifier"!==e.type)return null;switch(e.name){case "useEffect":case "useLayoutEffect":case "useCallback":case "useMemo":return 0;case "useImperativeHandle":return 1;default:if(e===a&&b&&b.additionalHooks){a=void 0;try{a=Y(e)}catch(f){if(/Unsupported node type/.test(f.message))return 0;throw f;}return b.additionalHooks.test(a)?0:-1}return-1}}
function Z(a,b){for(var e=[a],f=null;e.length;){f=e.shift();if("Identifier"===f.type&&f.name===b.name&&f.range[0]===b.range[0]&&f.range[1]===b.range[1])return f;if(da(f,b)){a=!0;var l=!1,t=void 0;try{for(var n=Object.entries(f)[Symbol.iterator](),v;!(a=(v=n.next()).done);a=!0){var h=v.value,r=h[1];"parent"!==h[0]&&(ja(r)?(r.parent=f,e.push(r)):Array.isArray(r)&&r.forEach(function(a){ja(a)&&(a.parent=f,e.push(a))}))}}catch(B){l=!0,t=B}finally{try{!a&&n.return&&n.return()}finally{if(l)throw t;}}}}return null}
function ka(a){for(var b="",e=0;e<a.length;e++)b+=a[e],0===e&&2===a.length?b+=" and ":e===a.length-2&&2<a.length?b+=", and ":e<a.length-1&&(b+=", ");return b}function ja(a){return"object"===typeof a&&null!==a&&!Array.isArray(a)&&"string"===typeof a.type}function da(a,b){return a.range[0]<=b.range[0]&&a.range[1]>=b.range[1]}
module.exports={rules:{"rules-of-hooks":{create:function(a){var b=[],e=[];return{onCodePathSegmentStart:function(a){return e.push(a)},onCodePathSegmentEnd:function(){return e.pop()},onCodePathStart:function(){return b.push(new Map)},onCodePathEnd:function(e,l){function f(a){var c=f.cache,d=c.get(a.id);if(null===d){if(!r.has(a.id)){r.add(a.id);c=!0;d=!1;var w=void 0;try{for(var q=a.prevSegments[Symbol.iterator](),b;!(c=(b=q.next()).done);c=!0)f(b.value)}catch(L){d=!0,w=L}finally{try{!c&&q.return&&
q.return()}finally{if(d)throw w;}}}return 0}if(void 0!==d)return d;c.set(a.id,null);if(e.thrownSegments.includes(a))d=0;else if(0===a.prevSegments.length)d=1;else{d=0;q=!0;b=!1;var h=void 0;try{w=a.prevSegments[Symbol.iterator]();for(var m;!(q=(m=w.next()).done);q=!0)d+=f(m.value)}catch(L){b=!0,h=L}finally{try{!q&&w.return&&w.return()}finally{if(b)throw h;}}}a.reachable&&0===d?c.delete(a.id):c.set(a.id,d);return d}function n(a){var c=n.cache,d=c.get(a.id);if(null===d){if(!r.has(a.id)){r.add(a.id);
c=!0;d=!1;var w=void 0;try{for(var q=a.nextSegments[Symbol.iterator](),b;!(c=(b=q.next()).done);c=!0)n(b.value)}catch(L){d=!0,w=L}finally{try{!c&&q.return&&q.return()}finally{if(d)throw w;}}}return 0}if(void 0!==d)return d;c.set(a.id,null);if(e.thrownSegments.includes(a))d=0;else if(0===a.nextSegments.length)d=1;else{d=0;q=!0;b=!1;var h=void 0;try{w=a.nextSegments[Symbol.iterator]();for(var f;!(q=(f=w.next()).done);q=!0)d+=n(f.value)}catch(L){b=!0,h=L}finally{try{!q&&w.return&&w.return()}finally{if(b)throw h;
}}}c.set(a.id,d);return d}function v(a){var c=v.cache,d=c.get(a.id);if(null===d)return Infinity;if(void 0!==d)return d;c.set(a.id,null);if(0===a.prevSegments.length)d=1;else{d=Infinity;var w=!0,q=!1,b=void 0;try{for(var e=a.prevSegments[Symbol.iterator](),h;!(w=(h=e.next()).done);w=!0){var f=v(h.value);f<d&&(d=f)}}catch(la){q=!0,b=la}finally{try{!w&&e.return&&e.return()}finally{if(q)throw b;}}d+=1}c.set(a.id,d);return d}var h=b.pop();if(0!==h.size){var r=new Set;f.cache=new Map;n.cache=new Map;v.cache=
new Map;var B=n(e.initialSegment),g=W(l),y=aa(l),C=g?U(g)||Q(g):!1,D=Infinity,k=!0,p=!1,H=void 0;try{for(var x=e.finalSegments[Symbol.iterator](),J;!(k=(J=x.next()).done);k=!0){var V=J.value;if(V.reachable){var P=v(V);P<D&&(D=P)}}}catch(m){p=!0,H=m}finally{try{!k&&x.return&&x.return()}finally{if(p)throw H;}}k=!0;p=!1;H=void 0;try{for(var A=h[Symbol.iterator](),K;!(k=(K=A.next()).done);k=!0){var E=K.value,F=E[0],R=E[1];if(F.reachable){var I=0===F.nextSegments.length?D<=v(F):D<v(F),S=f(F)*n(F),G=r.has(F.id);
h=!0;x=!1;J=void 0;try{for(var z=R[Symbol.iterator](),M;!(h=(M=z.next()).done);h=!0){var u=M.value;G&&a.report({node:u,message:'React Hook "'+a.getSource(u)+'" may be executed more than once. Possibly because it is called in a loop. React Hooks must be called in the exact same order in every component render.'});if(C){if(!G&&S!==B){var T='React Hook "'+a.getSource(u)+'" is called conditionally. React Hooks must be called in the exact same order in every component render.'+(I?" Did you accidentally call a React Hook after an early return?":
"");a.report({node:u,message:T})}}else if(!l.parent||"MethodDefinition"!==l.parent.type&&"ClassProperty"!==l.parent.type||l.parent.value!==l)if(g){var N='React Hook "'+a.getSource(u)+'" is called in '+('function "'+a.getSource(g)+'" ')+"which is neither a React function component or a custom React Hook function.";a.report({node:u,message:N})}else if("Program"!==l.type&&y){var O='React Hook "'+a.getSource(u)+'" cannot be called inside a callback. React Hooks must be called in a React function component or a custom React Hook function.';
a.report({node:u,message:O})}}}catch(m){x=!0,J=m}finally{try{!h&&z.return&&z.return()}finally{if(x)throw J;}}}}}catch(m){p=!0,H=m}finally{try{!k&&A.return&&A.return()}finally{if(p)throw H;}}}},CallExpression:function(a){if(Q(a.callee)){var f=b[b.length-1],t=e[e.length-1],n=f.get(t);n||(n=[],f.set(t,n));n.push(a.callee)}}}}},"exhaustive-deps":{meta:{fixable:"code",schema:[{type:"object",additionalProperties:!1,properties:{additionalHooks:{type:"string"}}}]},create:function(a){function b(a,b){return function(e){if(b.has(e))return b.get(e);
var h=a(e);b.set(e,h);return h}}function e(e){function h(a){var d=!0,c=!1,q=void 0;try{for(var b=a.references[Symbol.iterator](),f;!(d=(f=b.next()).done);d=!0){var g=f.value;if(g.resolved&&H.has(g.resolved.scope)){var l=Z(e,g.identifier),k=ea(l),m=Y(k),p;if(p=D&&"Identifier"===k.type&&"MemberExpression"===k.parent.type&&!k.parent.computed&&"Identifier"===k.parent.property.type&&"current"===k.parent.property.name){for(var n=g.from,r=!1;n.block!==e;)"function"===n.type&&(r=null!=n.block.parent&&"ReturnStatement"===
n.block.parent.type),n=n.upper;p=r}p&&P.set(m,{reference:g,dependencyNode:k});if(A.has(m))A.get(m).references.push(g);else{var t=g.resolved,v=J(t)||V(t);A.set(m,{isStatic:v,references:[g]})}}}}catch(X){c=!0,q=X}finally{try{!d&&b.return&&b.return()}finally{if(c)throw q;}}d=!0;c=!1;q=void 0;try{for(var u=a.childScopes[Symbol.iterator](),x;!(d=(x=u.next()).done);d=!0)h(x.value)}catch(X){c=!0,q=X}finally{try{!d&&u.return&&u.return()}finally{if(c)throw q;}}}function B(a,d,w,b){return 0===a.size?null:(1<
a.size?"":d+" ")+w+" "+(1<a.size?"dependencies":"dependency")+": "+ka(Array.from(a).sort().map(function(a){return"'"+a+"'"}))+(". Either "+b+" "+(1<a.size?"them":"it")+" or remove the dependency array.")}if(("FunctionExpression"===e.type||"ArrowFunctionExpression"===e.type)&&"CallExpression"===e.parent.type){var g=ia(e.parent.callee,f);if(e.parent.arguments[g]===e){var y=e.parent.callee,C=ha(y).name,D=C.endsWith("Effect"),k=e.parent.arguments[g+1];if(k){D&&e.async&&a.report({node:e,message:"Effect callbacks are synchronous to prevent race conditions. Put the async function inside:\n\nuseEffect(() => {\n  let ignore = false;\n  fetchSomething();\n\n  async function fetchSomething() {\n    const result = await ...\n    if (!ignore) setState(result);\n  }\n\n  return () => { ignore = true; };\n}, []);\n\nThis lets you handle multiple requests without bugs."});
var p=a.getScope(),H=new Set,x=null;for(g=p.upper;g;){H.add(g);if("function"===g.type)break;g=g.upper}if(g){x=g;var J=b(function(a){if(!Array.isArray(a.defs))return!1;var d=a.defs[0];if(null==d||"VariableDeclarator"!==d.node.type)return!1;var c=d.node.init;if(null==c)return!1;var b=d.node.parent;if(null==b&&(Z(x.block,d.node.id),b=d.node.parent,null==b))return!1;if("const"===b.kind&&"Literal"===c.type&&("string"===typeof c.value||"number"===typeof c.value||null===c.value))return!0;if("CallExpression"!==
c.type)return!1;c=c.callee;"MemberExpression"!==c.type||"React"!==c.object.name||null==c.property||c.computed||(c=c.property);if("Identifier"!==c.type)return!1;d=d.node.id;c=c.name;if("useRef"===c&&"Identifier"===d.type)return!0;if(("useState"===c||"useReducer"===c)&&"ArrayPattern"===d.type&&2===d.elements.length&&Array.isArray(a.identifiers)){if(d.elements[1]===a.identifiers[0]){if("useState"===c)for(a=a.references,c=0;c<a.length;c++)l.set(a[c].identifier,d.elements[0]);return!0}if(d.elements[0]===
a.identifiers[0]&&"useState"===c)for(a=a.references,d=0;d<a.length;d++)t.add(a[d].identifier)}return!1},n),V=b(function(a){if(!Array.isArray(a.defs))return!1;a=a.defs[0];if(null==a||null==a.node||null==a.node.id)return!1;var d=a.node,c=x.childScopes;a=null;var b;for(b=0;b<c.length;b++){var e=c[b],f=e.block;if("FunctionDeclaration"===d.type&&f===d||"VariableDeclarator"===d.type&&f.parent===d){a=e;break}}if(null==a)return!1;for(b=0;b<a.through.length;b++)if(d=a.through[b],null!=d.resolved&&H.has(d.resolved.scope)&&
!J(d.resolved))return!1;return!0},v),P=new Map,A=new Map;h(p);P.forEach(function(c,d){var b=c.dependencyNode;c=c.reference.resolved.references;for(var e=!1,f=0;f<c.length;f++){var g=c[f].identifier.parent;if(null!=g&&"MemberExpression"===g.type&&!g.computed&&"Identifier"===g.property.type&&"current"===g.property.name&&"AssignmentExpression"===g.parent.type&&g.parent.left===g){e=!0;break}}e||a.report({node:b.parent.property,message:"Accessing '"+d+".current' during the effect cleanup will likely read a different ref value because by this time React has already updated the ref. If this ref is managed by React, store "+
("'"+d+".current' in a variable inside ")+"the effect itself and refer to that variable from the cleanup function."})});var K=[],E=new Set;"ArrayExpression"!==k.type?a.report({node:k,message:"React Hook "+a.getSource(y)+" has a second argument which is not an array literal. This means we can't statically verify whether you've passed the correct dependencies."}):k.elements.forEach(function(c){if(null!==c)if("SpreadElement"===c.type)a.report({node:c,message:"React Hook "+a.getSource(y)+" has a spread element in its dependency array. This means we can't statically verify whether you've passed the correct dependencies."});
else{var d=void 0;try{d=Y(c)}catch(fa){if(/Unsupported node type/.test(fa.message)){"Literal"===c.type?"string"===typeof c.value?a.report({node:c,message:"The "+c.raw+" string literal is not a valid dependency because it never changes. Did you mean to "+("include "+c.value+" in the array instead?")}):a.report({node:c,message:"The '"+c.raw+"' literal is not a valid dependency because it never changes. You can safely remove it."}):a.report({node:c,message:"React Hook "+a.getSource(y)+" has a complex expression in the dependency array. Extract it to a separate variable so it can be statically checked."});
return}throw fa;}for(var b=c;"MemberExpression"===b.type;)b=b.object;var e=!x.through.some(function(a){return a.identifier===b});K.push({key:d,node:c});e||E.add(d)}});var F=new Set,R=new Set;A.forEach(function(c,d){var b=c.references;c.isStatic&&R.add(d);b.forEach(function(c){c.writeExpr&&(c=c.writeExpr,F.has(d)||(F.add(d),a.report({node:c,message:"Assignments to the '"+d+"' variable from inside a React "+a.getSource(y)+" Hook will not persist between re-renders. If it's only needed by this Hook, move the variable inside it. Alternatively, declare a ref with the useRef Hook, and keep the mutable value in its 'current' property."})))})});
if(!(0<F.size)){var I=ba({dependencies:A,declaredDependencies:K,optionalDependencies:R,externalDependencies:E,isEffect:D}),S=I.suggestedDependencies;g=I.unnecessaryDependencies;var G=I.missingDependencies;I=I.duplicateDependencies;if(0===I.size+G.size+g.size)ca({declaredDependencies:K,declaredDependenciesNode:k,componentScope:x,scope:p}).forEach(function(c){var d=c.fn,b=c.suggestUseCallback;c="The '"+d.name.name+"' function makes the dependencies of "+(C+" Hook (at line "+k.loc.start.line+") ")+"change on every render.";
c=b?c+(" To fix this, "+("wrap the '"+d.name.name+"' definition into its own useCallback() Hook.")):c+(" Move it inside the "+C+" callback. "+("Alternatively, wrap the '"+d.name.name+"' definition into its own useCallback() Hook."));a.report({node:d.node,message:c,fix:function(a){if(b&&"Variable"===d.type)return[a.insertTextBefore(d.node.init,"useCallback("),a.insertTextAfter(d.node.init,")")]}})});else{!D&&0<G.size&&(S=ba({dependencies:A,declaredDependencies:[],optionalDependencies:R,externalDependencies:E,
isEffect:D}).suggestedDependencies);(function(){if(0===K.length)return!0;var a=K.map(function(a){return a.key}),d=a.slice().sort();return a.join(",")===d.join(",")})()&&S.sort();var z="";if(0<g.size){var M=null;Array.from(g.keys()).forEach(function(a){null===M&&a.endsWith(".current")&&(M=a)});if(null!==M)z=" Mutable values like '"+M+"' aren't valid dependencies because their mutation doesn't re-render the component.";else if(0<E.size){var u=Array.from(E)[0];p.set.has(u)||(z=" Outer scope values like '"+
u+"' aren't valid dependencies because their mutation doesn't re-render the component.")}}if(!z&&G.has("props")){p=A.get("props");if(null==p)return;p=p.references;if(!Array.isArray(p))return;u=!0;for(var T=0;T<p.length;T++){var N=Z(x.block,p[T].identifier);if(!N){u=!1;break}N=N.parent;if(null==N){u=!1;break}if("MemberExpression"!==N.type){u=!1;break}}u&&(z=" However, the preferred fix is to destructure the 'props' "+("object outside of the "+C+" call and ")+"refer to specific props directly by their names.")}if(!z&&
0<G.size){var O=null;G.forEach(function(a){if(!O){var d=x.set.get(a),b=A.get(a);if(b.references[0].resolved===d&&(d=d.defs[0],null!=d&&null!=d.name&&"Parameter"===d.type)){d=!1;for(var c,e=0;e<b.references.length;e++)if(c=b.references[e].identifier,null!=c&&null!=c.parent&&"CallExpression"===c.parent.type&&c.parent.callee===c){d=!0;break}d&&(O=a)}}});null!==O&&(z=" If specifying '"+O+"' makes the dependencies change too often, find the parent component that defines it and wrap that definition in useCallback.")}if(!z&&
0<G.size){var m=null;G.forEach(function(a){if(null===m)for(var d=A.get(a).references,b,c,e=0;e<d.length;e++){b=d[e].identifier;for(c=b.parent;null!=c&&c!==x.block;){if("CallExpression"===c.type){var f=l.get(c.callee);if(null!=f){f.name===a?m={missingDep:a,setter:c.callee.name,form:"updater"}:t.has(b)?m={missingDep:a,setter:c.callee.name,form:"reducer"}:(b=d[e].resolved,null!=b&&(b=b.defs[0],null!=b&&"Parameter"===b.type&&(m={missingDep:a,setter:c.callee.name,form:"inlineReducer"})));break}}c=c.parent}if(null!==
m)break}});if(null!==m)switch(m.form){case "reducer":z=" You can also replace multiple useState variables with useReducer "+("if '"+m.setter+"' needs the ")+("current value of '"+m.missingDep+"'.");break;case "inlineReducer":z=" You can also replace useState with an inline useReducer "+("if '"+m.setter+"' needs the ")+("current value of '"+m.missingDep+"'.");break;case "updater":z=" You can also write '"+m.setter+"("+m.missingDep.substring(0,1)+" => ...)' if you only use '"+m.missingDep+"'"+(" for the '"+
m.setter+"' call.");break;default:throw Error("Unknown case.");}}a.report({node:k,message:"React Hook "+a.getSource(y)+" has "+(B(G,"a","missing","include")||B(g,"an","unnecessary","exclude")||B(I,"a","duplicate","omit"))+z,fix:function(a){return a.replaceText(k,"["+S.join(", ")+"]")}})}}}}else"useMemo"!==C&&"useCallback"!==C||a.report({node:e.parent.callee,message:"React Hook "+C+" doesn't serve any purpose without a dependency array. To enable this optimization, pass an array of values used by the "+
("inner function as the second argument to "+C+".")})}}}var f={additionalHooks:a.options&&a.options[0]&&a.options[0].additionalHooks?new RegExp(a.options[0].additionalHooks):void 0},l=new WeakMap,t=new WeakSet,n=new WeakMap,v=new WeakMap;return{FunctionExpression:e,ArrowFunctionExpression:e}}}}};
